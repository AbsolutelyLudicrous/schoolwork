	M. Danne Talks About Themself

	I'm boring. I'm a more-or-less ordinary high schooler aged 16-almost-17 who runs for fun and is a huge computer nerd.

	I'm not a half-bad runner; I consistently do under a 19:30 5k, and am consistently in the JV top-ten. I've been hoping to achieve varsity sometime this year; I just need to get another sub-18:40 under my belt.
	Running is a fun activity for me. Running, dashing, through throngs of people is an exhilirating experience. I, personally, try not to take the sport too seriously, but Coach will sometimes give us excruciating workouts. Occaisonally, they're to the team's detriment, but I think the tough days just prepare the team for the tough race days.

	I'm a huge computer nerd. A huge nerd in general, but primarily a computer nerd. I'm currently typing this memoir on my dead father's decade-old MSI U100 WiND, in NeoViM, running on FreeBSD-i386. I've gotten into computer-nerd-stuff almost accidentally; my freshman year of high school I took Introduction to Computer Science at the request of a friend. From there, I discovered a UNIX club held weekly by a branch of the Boy Scouts. A whole lot of stuff later, I wound up learning how to perform basic UNIX systems administration, three programming languages, two shells, and converted most boxes in my house to run either a Linux or a BSD.
	Let's dive into that more, actually. That last paragraph has a lot to dissect.
	My father is dead. His name was Andrew Ross Jackson, Andrew Jackson. He had nothing to do with the president; in fact, his parents had never heard of President Andrew Jackson. He, and his family, were Canadian. He was a highly paid dentist with his own practice, but had started out post-college life teaching maths in the Peace Corps, where he met my mother.
	So why do I still use a decade-old laptop, even though I have a shiny, fancy, modern, new, not-quite-top-of-the-line-but-still-pretty-good Asus K501? Different boxes for different tasks, really; the MSI has a nicer keyboard and is more compact. I don't use it often, it usually gets used for administering a NAS, Network Attached Storage, that I have. I call it a NAS, most people would call it a glorified Pi. My NAS isn't a server, it doesn't have units or fancy Xeon processors, or a UPS; it's just a Raspberry Pi3 with too many USB attachments. It isn't great for computing, but clock speed has no bearing on its ability to store files.
	NeoViM is a text editor. It's got a really weird story behind its name; The 'Neo' means 'new', of course, 'ViM' stands for 'Vi iMproved', 'Vi' stands for 'VIsual ex', 'ex' stands for 'Ed eXtended', and 'ed' is 'ed, the standard text EDitor.' ed, or something ed-like, being included in an operating system is part of POSIX compliancy. Any POSIX compliant, e.g. non-Windows, operating system should have ed, ex, or vi installed on it by default. In fact, OSX users can, right now, open Terminal, type 'vim', and learn to use the second-best command line text editor. Linux users should know how to do this already, BSD users are born knowing how to use vim, and Windows users would need to use CygWin or the Linux Subsystem for Windows to use vim.
	The operating system is neat too; I run FreeBSD-i386 on the MSI box. FreeBSD is a BSD, a Berkeley Software Distribution. It has its roots in orginal AT&T UNIX. About 0.01% of desktop computers run a BSD, although they see a slightly higher marketshare in the server operating system category. This doesn't mean BSDs are insignifigant, the BSDs have made meaningful contributions to the software ecosystem; Nintendo DSes, for example, borrow the BSD network stack.
	My freshman year of highschool, I took Introduction to Computer Science at the request of a friend. We don't talk much anymore, but I have to thank them for getting me interested in everything computer-related. At school I learned Java, an object-oriented, platform-independent programming language frequently criticized for being too verbose and restrictive. For some reason, Java wasn't enough for me; so I wound up learning some Python and C outside of school. From there, I bootstrapped my interests into learning, or rather trying to learn, almost everything. I spend most of my free time challenging myself to do new things in every language I claim to know, working on personal projects, or (ab)using POSIX shell.
	I learned a bunch of shell for some reason. I just took a liking to it, and now will rarely not have at least one terminal emulator open at all times. I now have extensive experience with zsh and bash. I'm most comfortable is zsh, although I do all of my scripting in bash, for portability.
	My greatest feat of UNIXing has probably been converting all boxes in my house to run either a Linux or a BSD. My aging iMac dual-boots OSX (which has its roots in BSD!) and Solus, my main laptop runs Solus and has space for a dual-boot, my Raspberry Pi3 runs OpenMediaVault, and my old MSI laptop runs FreeBSD. It's a very niche feat, but still one I'm proud of.
	I have other feats I'm proud of. I have a whole bunch of personal projects, some of which I'm reticient to talk about, I've been working on. All but one is on GitHub, a version control system, and are largely not-abandoned. For example, I've been working on a unified package manager frontend for several operating systems. A package manager is a utility for managing what software is installed on a system. Windows lacks a package manager, OSX has a community-maintained one, the Linuxes have several, and the BSDs have one. What makes writing a frontend hard, even though I'm only doing it in bash, is balancing portability and maintainability. For one thing, most Linuxes and BSDs have their bash installed in different locations. Some distributions decide to add symbolic links for the sake of binary compatibility, but most don't. This makes adding a proper shebang challenging, and necessitates a bootstrapping script to locate the system's bash install location. Occaisonally, I feel like undertaking such a project is folly, but having my systems work in harmony is a wonderful experience.
